% !tex encoding = utf-8 unicode

% this is a simple template for a latex document using the "article" class.
% see "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% packages
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={3.0},
]{doclicense}

\usepackage[utf8]{inputenc} % set input encoding (not needed with xelatex)
\usepackage[strict]{changepage}
    
    %%% examples of article customizations
    % these packages are optional, depending whether you want the features they provide.
    % see the latex companion or other references for full information.
    
    
    %%% page dimensions
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (us) or a5paper or....
    % \geometry{margin=2in} % for example, change the margins to 2 inches all round
    % \geometry{landscape} % set up the page for landscape
    %   read geometry.pdf for detailed page layout information
 \usepackage{numdef}
   
\usepackage{graphicx} % support the \includegraphics command and options
    % some of the article customisations are relevant for this class
\usepackage{amsmath,amsthm}
\usepackage{amsfonts} % math fonts such as \mathbb{}
\usepackage{amssymb} % \therefore
% \usepackage{bickham}
\usepackage{hyperref}
\usepackage{cryptocode}
\usepackage{framed} 
    % \usepackage[parfill]{parskip} % activate to begin paragraphs with an empty line rather than an indent
    
    %%% packages
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. Enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
    % % these packages are all incorporated in the memoir class to one degree or another...
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{adjustbox}

\usepackage{pgfplots}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
  
    %%% headers & footers
\usepackage{fancyhdr} % this should be set after setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}
    
    
    %%% section title appearance
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (see the fntguide.pdf for font help)
    % (this matches context defaults)
    
    %%% toc (table of contents) appearance
\usepackage[nottoc,notlof,notlot]{tocbibind} % put the bibliography in the toc
\usepackage[titles,subfigure]{tocloft} % alter the style of the table of contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % no bold!

 %%% end article customizations
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % macros
 \newcommand{\code}[1]{\texttt{#1}}
\newcommand\tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut
\newcommand{\bgamma}{\boldsymbol{\gamma}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
\newcommand{\plonk}{\ensuremath{\mathcal{P} \mathfrak{lon}\mathcal{K}}\xspace}
\newcommand{\cq}{\ensuremath{\mathpgoth{cq} }\xspace}
\newcommand{\cqstar}{\ensuremath{\mathpgoth{cq^{\mathbf{*}} }}\xspace}
\newcommand{\flookup}{\ensuremath{\mathsf{\mathpgoth{Flookup}}}\xspace}
\newcommand{\baloo}{\ensuremath{\mathrm{ba}\mathit{loo}}\xspace}
\newcommand{\caulkp}{\ensuremath{\mathsf{\mathrel{Caulk}\mathrel{\scriptstyle{+}}}}\xspace}
\newcommand{\caulk}{\ensuremath{\mathsf{Caulk}}\xspace}
\newcommand{\plookup}{\ensuremath{\mathpgoth{plookup}}\xspace}
\newcommand{\tablegroup}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\V}{\ensuremath{\mathbf{V} }\xspace}



% \newcommand{\plonk}{\ensuremath{\mathtt{PLONK}}\xspace}
\newcommand{\papertitle}{\cq:\footnote{Pronounced ``seek you''.} Cached quotients for fast lookups}
%\newcommand{\authorname}}
\newcommand{\company}{}
\title{ \bf \papertitle \\[0.72cm]}
\author{ Liam Eagen \and  Dario Fiore \\ \tt{IMDEA}  \and Ariel Gabizon \\ \tt{Zeta Function Technologies} } 
% 
% 	\large{\authorname} \\[0.5cm] \large{\company}
% 	\\ {DRAFT}
%}
%\date{} % activate to display a given date or no date (if empty),

% otherwise the current date is printed 
\DeclareMathAlphabet{\mathpgoth}{OT1}{pgoth}{m}{n}	
\ProvidesPackage{numdef}



%% Ariel Macros:
\num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\Gi}{\ensuremath{{\mathbb G}_i}\xspace}
%\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}
\newcommand{\x}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\z}{\ensuremath{\mathbf{z}}\xspace}
\newcommand{\X}{\ensuremath{\mathbf{X}}\xspace}

\num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0} }\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0} }\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}
\newcommand{\prvperm}{\ensuremath{\mathrm{P_{\mathsf{\sigma}}}}\xspace}
\newcommand{\verperm}{\ensuremath{\mathrm{V_{\mathsf{\sigma}}}}\xspace}
\newcommand{\alg}{\ensuremath{\mathscr{A}}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}
\newcommand{\chalpoint}{\ensuremath{\mathfrak{z}}\xspace}

\newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
\newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
\newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{(#1)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{\mathcal A}\xspace}
\newcommand{\advprime}{\ensuremath{{\mathcal A}'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}
\newcommand{\advrand}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
% \num\newcommand{\srs1}{\ensuremath{\mathsf{srs_1}}\xspace}
% \num\newcommand{\srs2}{\ensuremath{\mathsf{srs_2}}\xspace}
\newcommand{\srs}{\ensuremath{\mathsf{srs}}\xspace}
\newcommand{\srsbase}{\ensuremath{\mathsf{srs_0}}\xspace}
\newcommand{\srsi}{\ensuremath{\mathsf{srs_i}}\xspace}
\newcommand{\com}{\ensuremath{\mathsf{com}}\xspace}
\newcommand{\comperm}{\ensuremath{\mathsf{com_{\sigma}}}\xspace}
\newcommand{\cm}{\ensuremath{\mathsf{cm}}\xspace}
\newcommand{\cmsig}{\ensuremath{\mathsf{cm_\sigma}}\xspace}
\newcommand{\open}{\ensuremath{\mathsf{open}}\xspace}
\newcommand{\openperm}{\ensuremath{\mathsf{open_{\sigma}}}\xspace}
\newcommand{\sigof}[1]{\ensuremath{\sigma(#1)}\xspace}
\newcommand{\proverexp}{\ensuremath{\mathsf{e}}\xspace}
\newcommand{\reducedelems}{\ensuremath{\mathsf{r}}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\renewcommand{\deg}{\ensuremath{\mathrm{deg}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}
\newcommand{\abase}{\ensuremath{A_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\bbase}{\ensuremath{B_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\cbase}{\ensuremath{C_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\bliop}[1]{\ensuremath{\mathsf{#1{\text{-}}{BLIOP}}}\xspace}
\newcommand{\blop}{\ensuremath{\mathsf{\mathscr{BL} {\text{-}}IOP}}\xspace}
\newcommand{\openprotinput}{\ensuremath{\mathcal{O}}\xspace}
\newcommand{\amid}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\bmid}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\cmid}{\ensuremath{C_{\mathrm{mid}}}\xspace}

\newcommand{\negl}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2
\newcommand{\nilp}{\ensuremath{\mathscr N}\xspace}
\newcommand{\groupgen}{\ensuremath{\mathscr G}\xspace}
\newcommand{\qap}{\ensuremath{\mathscr Q}\xspace}
\newcommand{\polprot}[4]{$(#1,#2,#3,#4)$-polynomial protocol}
\newcommand{\rangedprot}[5]{$#5$-ranged $(#1,#2,#3,#4)$-polynomial protocol}

\newcommand{\rej}{\ensuremath{\mathsf{rej}}\xspace}
\newcommand{\acc}{\ensuremath{\mathsf{acc}}\xspace}
\newcommand{\res}{\ensuremath{\mathsf{res}}\xspace}
\newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
 \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\mathsf{comm}_{#1}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\B}{\ensuremath{\vec{B}}\xspace}
\newcommand{\dom}{\ensuremath{H}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\Btwo}{\ensuremath{\vec{B_2}}\xspace}
\newcommand{\treevecsimp}{\ensuremath{(\tau,\rho_A,\rho_A \rho_B,\rho_A\alpha_A,\rho_A\rho_B\alpha_B, \rho_A\rho_B\alpha_C,\beta,\beta\gamma)}\xspace}% The sets of elements used in simplifed relation tree in main text body
\newcommand{\rcptc}{random-coefficient subprotocol\xspace}
\newcommand{\rcptcparams}[2]{\ensuremath{\mathrm{RCPC}(#1,#2)}\xspace}
\newcommand{\verifyrcptcparams}[2]{\ensuremath{\mathrm{\mathsf{verify}RCPC}(#1,#2)}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{ #1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
 \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
 \newcommand{\partition}{\ensuremath{{\mathcal T}}\xspace}
 \newcommand{\partof}[1]{\ensuremath{{\partition_{#1}}}\xspace}
\num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
\num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
 \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
 \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace} 
\newcommand{\hash}{\ensuremath{\mathcal{H}}\xspace} 
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace} 
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\trapdoor}{\ensuremath{r}}
\newcommand{\trapdoorext}{\ensuremath{r_{\mathrm{ext}}}\xspace}
\newcommand{\trapdoorsim}{\ensuremath{r_{\mathrm{sim}}}\xspace}
\renewcommand{\mod}{\ensuremath{\;\mathrm{mod}\;}}
\newcommand{\hsub}{\ensuremath{H^*}\xspace}
\num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
\newcommand{\enci}[1]{\ensuremath{\left[#1\right]_i}\xspace}
\num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}
\newcommand{\gen}{\ensuremath{\mathsf{gen}}\xspace}
\newcommand{\prv}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\prvpoly}{\ensuremath{\mathrm{P_{\mathsf{poly}}}}\xspace}
\newcommand{\prvpc}{\ensuremath{\mathrm{P_{\mathsf{PC}}}}\xspace}
\newcommand{\verpoly}{\ensuremath{\mathrm{V_{\mathsf{poly}}}}\xspace}
\newcommand{\verpc}{\ensuremath{\mathrm{V_{\mathsf{PC}}}}\xspace}
\newcommand{\ideal}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\prf}{\ensuremath{\pi}\xspace}
\newcommand{\simprv}{\ensuremath{\mathrm{P^{sim}}}\xspace}

%\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\inp}{\ensuremath{\mathsf{x}}\xspace}
\newcommand{\wit}{\ensuremath{\omega}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{\mathbf{V}}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\sonic}{\ensuremath{\mathsf{Sonic}}\xspace}
\newcommand{\aurora}{\ensuremath{\mathsf{Aurora}}\xspace}
\newcommand{\auroralight}{\ensuremath{\mathsf{Auroralight}}\xspace}
\newcommand{\groth}{\ensuremath{\mathsf{Groth'16}}\xspace}
\newcommand{\kate}{\ensuremath{\mathsf{KZG}}\xspace}
\newcommand{\rel}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\lang}{\ensuremath{\mathcal{L}}\xspace}
\newcommand{\ext}{\ensuremath{E}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{ {\mathcal A}^{\mathbf{*}}}\xspace} % the adversary that uses protocol adversary as black box
\newcommand{\crs}{\ensuremath{\sigma}\xspace}
%\num\newcommand{\crs1}{\ensuremath{\mathrm{\sigma}_1}\xspace}
%\num\newcommand{\crs2}{\ensuremath{\mathrm{\sigma}_2}\xspace}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand{\hgen}{\ensuremath{\mathbf{\omega}}\xspace}
\newcommand{\vgen}{\ensuremath{\mathbf{g}}\xspace}
\renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
\renewcommand{\neg}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathcal R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
 \newcommand{\bivar}[1]{\ensuremath{\F_{< #1}[X,Y]}\xspace}
 \newcommand{\sig}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\prot}{\ensuremath{\mathscr{P}}\xspace}
 \newcommand{\PCscheme}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\protprime}{\ensuremath{\mathscr{P^*}}\xspace}
 \newcommand{\sigprv}{\ensuremath{\mathsf{P_{sc}}}\xspace}
 \newcommand{\sigver}{\ensuremath{\mathsf{V_{sc}}}\xspace}
 \newcommand{\sigpoly}{\ensuremath{\mathsf{S_{\sigma}}}\xspace}
 \newcommand{\idpoly}{\ensuremath{\mathsf{S_{ID}}}\xspace}
\newcommand{\idpolyevala}{\ensuremath{\mathsf{\bar{s}_{ID1}}}\xspace}
\newcommand{\sigpolyevala}{\ensuremath{\mathsf{\bar{s}_{\sigma1}}}\xspace}
\newcommand{\sigpolyevalb}{\ensuremath{\mathsf{\bar{s}_{\sigma2}}}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\PIb}{\ensuremath{\mathsf{PI_B}}\xspace}
\newcommand{\PIc}{\ensuremath{\mathsf{PI_C}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\newcommand{\obgen}{\ensuremath{\mathcal O}\xspace}
\newcommand{\PC}{\ensuremath{\mathscr{P}}\xspace}
\newcommand{\permscheme}{\ensuremath{\sigma_\mathscr{P}}\xspace}

	
\newcommand{\selleft}{\ensuremath{\mathbf{q_L}}\xspace}
\newcommand{\selright}{\ensuremath{\mathbf{q_R}}\xspace}
\newcommand{\selout}{\ensuremath{\mathbf{q_O}}\xspace}
\newcommand{\selmult}{\ensuremath{\mathbf{q_M}}\xspace}
\newcommand{\selconst}{\ensuremath{\mathbf{q_C}}\xspace}
\newcommand{\selectors}{\ensuremath{\mathcal{Q}}\xspace}
\newcommand{\lvar}{\ensuremath{\mathbf{a}}\xspace}
\newcommand{\vars}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\rvar}{\ensuremath{\mathbf{b}}\xspace}
\newcommand{\ovar}{\ensuremath{\mathbf{c}}\xspace}
\newcommand{\pubvars}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\assignment}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\constsystem}{\ensuremath{\mathscr{C}}\xspace}
\newcommand{\relof}[1]{\ensuremath{\rel_{#1}}\xspace}
\newcommand{\pubinppoly}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\sumi}[1]{\sum_{i\in[#1]}}
\newcommand{\summ}[1]{\sum_{i\in[#1]}}
\newcommand{\sumj}[1]{\sum_{j\in[#1]}}
\newcommand{\ZeroH}{\ensuremath{Z_{H}} \xspace}
\newcommand{\lpoly}{\ensuremath{\mathsf{a}}\xspace}
\newcommand{\rpoly}{\ensuremath{\mathsf{b}}\xspace}
\newcommand{\opoly}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\idpermpoly}{\ensuremath{\mathsf{z}}\xspace}
\newcommand{\lagrangepoly}{\ensuremath{\mathsf{L}}\xspace}
\newcommand{\zeropoly}{\ensuremath{\mathsf{\ZeroH}}\xspace}
\newcommand{\selmultpoly}{\ensuremath{\mathsf{q_M}}\xspace}
\newcommand{\selleftpoly}{\ensuremath{\mathsf{q_L}}\xspace}
\newcommand{\selrightpoly}{\ensuremath{\mathsf{q_R}}\xspace}
\newcommand{\seloutpoly}{\ensuremath{\mathsf{q_O}}\xspace}
\newcommand{\selconstpoly}{\ensuremath{\mathsf{q_C}}\xspace}
\newcommand{\idcomm}{\ensuremath{[s_{\mathsf{ID1}}]_1}\xspace}
\newcommand{\sigcomma}{\ensuremath{[s_{\mathsf{\sigma1}}]_1}\xspace}
\newcommand{\sigcommb}{\ensuremath{[s_{\mathsf{\sigma2}}]_1}\xspace}
\newcommand{\sigcommc}{\ensuremath{[s_{\mathsf{\sigma3}}]_1}\xspace}
\newcommand{\selleftcomm}{\ensuremath{[q_\mathsf{L}]_1}\xspace}
\newcommand{\selrightcomm}{\ensuremath{[q_\mathsf{R}]_1}\xspace}
\newcommand{\seloutcomm}{\ensuremath{[q_\mathsf{O}]_1}\xspace}
\newcommand{\selconstcomm}{\ensuremath{[q_\mathsf{C}]_1}\xspace}
\newcommand{\selmultcomm}{\ensuremath{[q_\mathsf{M}]_1}\xspace}

\newcommand{\multlinecomment}[1]{\directlua{-- #1}}
    

\newtheorem{lemma}{Lemma}[section]
\newtheorem{thm}[lemma]{Theorem}
\newtheorem{dfn}[lemma]{Definition}
\newtheorem{remark}[lemma]{Remark}

\newtheorem{claim}[lemma]{Claim}
\newtheorem{corollary}[lemma]{Corollary}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\crct}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\A}{\mathcal{A}}
%\newcommand{\G}{\mathcal{G}}
\newcommand{\Gr}{\mathbb{G}}
%\newcommand{\com}{\textsf{com}}  Ariel defined equivalent that also works in math mode
\newcommand{\cgen}{\text{cgen}}
\newcommand{\poly}{\ensuremath{\mathsf{poly(\lambda)}}\xspace}
\newcommand{\snark}{\ensuremath{\mathsf{snark}}\xspace}
\newcommand{\grandprod}{\mathsf{prod}}
\newcommand{\perm}{\mathsf{perm}}
%\newcommand{\open}{\mathsf{open}}
\newcommand{\update}{\mathsf{update}}
\newcommand{\Prove}{\mathcal{P}}
\newcommand{\Verify}{\mathcal{V}}
\newcommand{\Extract}{\mathcal{E}}
\newcommand{\Simulate}{\mathcal{S}}
\newcommand{\Unique}{\mathcal{U}}
\newcommand{\Rpoly}{\R{\poly}}
\newcommand{\Ppoly}{\Prove{\poly}}
\newcommand{\Vpoly}{\Verify{\poly}}
\newcommand{\Psnark}{\prv}%{\Prove{\snark}}
\newcommand{\Vsnark}{\ver}%{\Verify{\snark}}
\newcommand{\Rprod}{\R{\grandprod}}
\newcommand{\Pprod}{\Prove{\grandprod}}
\newcommand{\Vprod}{\Verify{\grandprod}}
\newcommand{\Rperm}{\R{\perm}}
\newcommand{\Pperm}{\Prove{\perm}}
\newcommand{\Vperm}{\Verify{\perm}}
% \newcommand{\zw}[1]{{\textcolor{magenta}{Zac:#1}}}
% \newcommand{\ag}[1]{{\textcolor{blue}{\emph{Ariel:#1}}}}
\newcommand{\prob}{\ensuremath{\mathrm{Pr}}\xspace}
\newcommand{\extprot}{\ensuremath{E_{\prot}}\xspace}
\newcommand{\transcript}{\ensuremath{\mathsf{transcript}}\xspace}
\newcommand{\extpc}{\ensuremath{E_{\PCscheme}}\xspace}
\newcommand{\advpc}{\ensuremath{\mathcal A_{\PCscheme}}\xspace}
\newcommand{\advprot}{\ensuremath{\mathcal A_{\prot}}\xspace}
\newcommand{\protmany}{\ensuremath{ {\prot}_k}\xspace}

\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\marlin}{\ensuremath{\mathsf{Marlin}}\xspace}
\newcommand{\fractal}{\ensuremath{\mathsf{Fractal}}\xspace}
% \newcommand{\Rsnark}{\R{\snark}}
\newcommand{\Rsnark}{\R}
\newcommand{\subvec}[1]{\ensuremath{#1|_{\subspace}}\xspace}
\newcommand{\restricttoset}[2]{\ensuremath{#1|_{#2}}\xspace}
\newcommand{\isinvanishing}[1]{\ensuremath{\mathsf{IsInVanishing_{\subspace,#1}}}\xspace}
\newcommand{\batchedisinvanishing}[1]{\ensuremath{\mathsf{BatchedIsInVanishing_{\subspace,#1}}}\xspace}
\newcommand{\isconsistent}{\ensuremath{\mathsf{IsConsistent}}\xspace}
\newcommand{\isintable}{\ensuremath{\mathsf{IsInTable_{\subspace}}}\xspace}
\newcommand{\isinvanishingtable}[1]{\ensuremath{\mathsf{IsInVanishingTable_{\subspace,#1}}}\xspace}
\newcommand{\isvanishingsubtable}[1]{\ensuremath{\mathsf{IsVanishingSubtable_{#1}}}\xspace}
\newcommand{\haslowerdegree}{\ensuremath{\mathsf{HasLowerDegree}}\xspace}
\newcommand{\haslowdegree}[1]{\ensuremath{\mathsf{HasLowDegree_{#1}}}\xspace}
\newcommand{\issubtable}[1]{\ensuremath{\mathsf{IsSubtable_{#1}}}\xspace}
\newcommand{\isinsubtable}[2]{\ensuremath{\mathsf{IsInSubtable_{#1,#2}}}\xspace}
\newcommand{\secbasezero}[1]{\ensuremath{\hat{\tau}_{#1}}\xspace}
\newcommand{\secbase}[1]{\ensuremath{\hat{\tau}_{#1}}\xspace}
\newcommand{\secbasereg}[1]{\ensuremath{\tau_{#1}}\xspace}
\newcommand{\secset}{\ensuremath{I}\xspace}
\newcommand{\pubbase}[1]{\ensuremath{\mu_{#1}}\xspace}
\newcommand{\subspace}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\bigspace}{\ensuremath{\mathbb{V}}\xspace}
\newcommand{\subtable}{\ensuremath{T_0}\xspace}
\newcommand{\tablelang}{\ensuremath{\lang_{T}}\xspace}
\newcommand{\vanishingtablelang}{\ensuremath{\lang_{\subspace}}\xspace}
\newcommand{\nonorm}[1]{\ensuremath{\Gamma^T_{#1}}\xspace}
\newcommand{\unnorm}[2]{\ensuremath{\Gamma^{#1}_{#2}}\xspace}
\newcommand{\bigspacebase}{\ensuremath{\lambda}\xspace}
\newcommand{\bigspacegen}{\ensuremath{\mathsf{h}}\xspace}
\newcommand{\modvan}[1]{\ensuremath{\mathrm{mod\;}Z_{#1}}\xspace}
\newcommand{\extractevaltable}{\ensuremath{\mathsf{ExtractEvalTable}_{C,\tablegroup}}\xspace}
\newcommand{\witsize}{\ensuremath{n}\xspace}
\newcommand{\witruntime}{\ensuremath{\witsize\log\witsize}\xspace}
\newcommand{\tabsize}{\ensuremath{N}\xspace}
\newcommand{\tabruntime}{\ensuremath{\tabsize\log\tabsize}\xspace}
\newcommand{\tab}{\ensuremath{\mathfrak{t}}\xspace}
 \renewcommand{\a}{\ensuremath{\mathsf{a}}\xspace}
\renewcommand{\b}{\ensuremath{\mathsf{b}}\xspace}
\renewcommand{\c}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\f}{\ensuremath{\mathsf{f}}\xspace}
\newcommand{\ftwo}{\ensuremath{\mathsf{f}_2}\xspace}
\renewcommand{\p}{\ensuremath{\mathsf{p}}\xspace}
\newcommand{\qa}{\ensuremath{\mathsf{q_a}}\xspace}
\newcommand{\qb}{\ensuremath{\mathsf{q_b}}\xspace}
\newcommand{\m}{\ensuremath{\mathsf{m}}\xspace}
\newcommand{\agam}{\ensuremath{a_\gamma}\xspace}
\newcommand{\gamproof}{\ensuremath{\mathsf{\pi_\gamma}}\xspace}
\newcommand{\zerproof}{\ensuremath{\mathsf{\pi_0}}\xspace}
\newcommand{\bgam}{\ensuremath{b_\gamma}\xspace}
\newcommand{\qbgam}{\ensuremath{Q_{b,\gamma}}\xspace}
\newcommand{\zgam}{\ensuremath{Z_{\bigspace,\gamma}}\xspace}
\newcommand{\fgam}{\ensuremath{f_{\gamma}}\xspace}
\newcommand{\pgam}{\ensuremath{P_{\gamma}}\xspace}
\newcommand{\supp}[1]{\ensuremath{\mathrm{supp}(#1)}\xspace}

\begin{document}
    \maketitle
\begin{abstract}
 We present a protocol for checking the values of a committed polynomial $f(X)\in \polysofdeg{\tabsize}$ over a multiplicative subgroup $\subspace\subset \F$ of size \witsize are contained in a
 table $\tab\in \F^\tabsize$. After an $O(\tabsize \log \tabsize)$ preprocessing step, the prover algorithm runs in time $O(\witsize\log \witsize)$.
 Thus, we continue to improve upon the recent breakthrough sequence of results\cite{caulk,caulkp,flookup,baloo} starting from \caulk~\cite{caulk}, which achieve sublinear complexity in the table size \tabsize. The two most recent works in this seqence \cite{flookup,baloo} achieved
 prover complexity $O(\witsize\cdot \log^2 \witsize)$.
 
 Moreover, \cq has the following attractive features.
 \begin{enumerate}
  \item As in \cite{caulk,caulkp,baloo} our construction relies on homomorphic table commitments, which makes them amenable to vector lookups in the manner described in Section 4 of \cite{plookup}.
 \item As opposed to \cite{caulk,caulkp,flookup,baloo} the \cq verifier doesn't involve pairings with prover defined \G2 points, which makes recursive aggregation of proofs more convenient.
 
\item The construction can be altered to a version we call \cqstar that loses the mentioned aggregatability, increase preprocessing time to $O(\witsize\cdot \tabsize)$, and in return reduce prover complexity to a \emph{linear} number of field and group operations!
 \end{enumerate}
 \end{abstract}

% !TEX root = ../flookup.texV

\section{Introduction}
The \emph{lookup problem} is fundamental to the efficiency of modern zk-SNARKs.
Somewhat informally, it asks for a protocol to prove the values of a committed polynomial $\phi(X)\in\polysofdeg{\witsize}$ are contained in a table $T$ of size $\tabsize$ of predefined legal values.
When the table $T$ corresponds to an operation without an efficient low-degree arithmetization in $\F$, such a protocol produces significant savings in proof construction time for programs containing the operation.
Building on previous work of \cite{arya}, \plookup \cite{plookup} was the first to explicitly describe a solution to this problem in the polynomial-IOP context. \plookup described a protocol with prover complexity quasilinear in both \witsize and \tabsize.
This left the intriguing question of whether the dependence on \tabsize could be made \emph{sublinear} after performing a preprocessing step for the table $T$.
\caulk \cite{caulk} answered this question in the affirmative by leveraging bi-linear pairings, achieving a run time of $O(\witsize^2+\witsize\log \tabsize)$. \caulkp \cite{caulkp} improved this to $O(\witsize^2)$ getting rid of the dependence on table size completely. 

However, the quadratic dependence on \witsize  of these works makes them impractical for a circuit with many lookup gates.
We resolve this issue by giving a protocol called \cq that is quasi-linear in \witsize and has no dependence on \tabsize after the preprocessing step.

\subsection{Comparison of results}
\begin{table}[!htbp]
	\caption{Scheme comparison. $\witsize$ = witness size, \tabsize = Table size, ``Aggregatable''= All prover defined pairing arguments in \G1}
	\centering
\begin{adjustbox}{width=1\textwidth}
	\begin{tabular}{l|l|l|l|l|l|l}
	\thead{Scheme} & \thead{Preprocessing} & \thead{Proof size} & \thead{Prover Work} & \thead{Verifier Work} & \thead{Homomorphic?} & \thead{Aggregatable?} \\ \hline
		\caulk\cite{caulk}
		        & O(\tabruntime) \F,\G1 & $14$ \G1, 1 \G2, 4 \F      & \makecell[l]{$3n + m - \ell$ \G1 exp, \\ $n$ \G2 exp} & $2$ \G1, $1$ \G2 & \cmark & \xmark \\ \hline
		\caulkp\cite{caulkp} & $O(\tabruntime)$ \F,\G1 & $7$ \G1, $1$ \G2, $2$ \F      &   $18n$ \G1 exp      & $4$ \G1, $2$ $\F$ & \cmark & \xmark \\ \hline
		\flookup\cite{flookup} & $O(\tabsize \log^2 \tabsize)$ \F,\G1             & $6$ \G1, $1$ \G2, $4$ \F  & $273n$ \G1 exp           & $20$ \G1, $16$ \F & \xmark & \xmark \\ \hline
		\baloo\cite{baloo}       & $O(\tabruntime)$ \F,\G1   & $12$ \G1, $1$ \G2, $4$ \F    & $8n$ \G1 exp         & $6$ \G1, $4$ \F & \cmark & \xmark \\ \hline
		\cq          & $O(\tabruntime)$ \F,\G1     & $8$ \G1, $4$ \F & \makecell[l]{$11n + 11a$ \G1 exp , \\ $\approx54(n+a)\text{log}(n+a)$ \F mul}        & $7$ \G1, $6$ \F & \cmark & \cmark \\ \hline
		\cqstar          &   \makecell[l]{$O(\tabruntime + \tabsize\cdot \witruntime)$ \F,\G1 \\ $O(\witruntime)$ \G2}  & $6$ \G1, $1$ \G2, $1$ \F & \makecell[l]{$9n + 9a$ \G1 exp , \\ $\approx54(n+a)\text{log}(n+a)$ \F mul}        & $9$ \G1, $6$ \F & \cmark & \xmark \\ \hline
	\end{tabular}
\end{adjustbox}
\label{table:prover-work}
\end{table} \

Table with relative proof size, prover ops, verifier ops
                proof-size
caulk
caulk+
flookup
baloo         12 \G1, 1 \G2, 4 \F
this work  6 G1, 1 G2

\subsection{Technical Overview}
\paragraph{The innovation of \caulk }
While \cite{caulk,caulkp,flookup,baloo} use preprocessing and pairings to extract a subtable of witness size;


\paragraph{Our approach}
here we use preprocessing and pairings more directly to run an existing lookup protocol - mvlookup,
in time independent from table size
-logarithmic derivative method
Let's review this protocol:
It relies on the following lemma from \cite{mvlookup}
that says that $\restricttoset{f}{\subspace}\in \tab$ if and only if for some $m\in \F^\tabsize$
 \[\sumi{\tabsize}\frac{m_i}{X+t_i}=\sumi{\witsize}\frac{1}{X+f_i}\]
Roughly, the protocol of \cite{mvlookup} checks this identity on a random $\beta$,
by sending polynomials $A$ and $B$ that agree on \bigspace with the rational function values of the LHS and RHS
respectively.
Given commitments to $A,B$ we can check the equality holds via various sumcheck techniques, e.g. that descirbed in \cite{aurora}.
The RHS is not a problem because it is a sum of size \witsize.
Interpolating $A$, and computing its commitment is actually not a problem either, because the number of non-zero values
is at most \witsize. So if we precompute the commitments to the Lagrange base of  \bigspace we're fine.

The main challenge, and innovation, is to convince the verifier \ver that $A$ is correctly formed.


This protocol is amenable, because polynomials involved have sparsity depending on witness
- For large table problem is computing A that agrees with $m/(\tab+\beta)$ on \bigspace

- Need way to compute $A$ 
\section{Preliminaries}
\subsection{Terminology and Conventions}\label{sec:terminology}
We assume our field \F is of prime order.
%We assume we have a
%multiplicative subgroup $H \subset F$ of size $|H| = n$ where $n$ is the number of constraints in our R1CS.
%and denote for simplicity the elements of H as H = {1, . . . , m}.
%We assume the number of private variables n is equal to m.
We denote by \polysofdeg{d} the set of univariate polynomials over \F of degree smaller than d. 
We assume all algorithms described receive as an implicit parameter the security parameter $\lambda$.

Whenever we use the term \emph{efficient}, we mean an algorithm running in time \poly. Furthermore,
we assume an \emph{object generator} \obgen that is run with input $\lambda$ before all protocols, and returns all fields and groups used. Specifically, in our protocol $\obgen(\lambda) = (\F, \G1, \G2, \Gt, e, g_1, g_2,g_t)$ where
\begin{itemize}
\item \F is a prime field of super-polynomial size $r = \lambda^{\omega(1)}$
.
\item $\G1,\G2,\Gt$ are all groups of size $r$, and $e$ is an efficiently computable non-degenerate pairing
$e : \G1 \times \G2 \to \Gt$.
\item $g_1,g_2$ are uniformly chosen generators such that $e(g_1, g_2) = g_t$.
\end{itemize}
We usually let the $\lambda$ parameter be implicit, i.e.\ write \F instead of $\F(\lambda)$.
We write \G1 and \G2 additively. We use the notations $\enc1{x}\defeq x\cdot g_1$ and $\enc2{x}\defeq x\cdot g_2$.

We often denote by $[n]$ the integers \set{1,\ldots,n}.
% For example, when we refer below to the field $\F$, it is in fact a function $\F(\lambda)$ of $\lambda$, and part of
% the output of $\obgen(\lambda)$.
We use the acronym e.w.p for ``except with probability''; i.e. e.w.p $\gamma$ means with probability \emph{at least} $1-\gamma$.

\paragraph{universal SRS-based public-coin protocols}
We describe public-coin (meaning the verifier messages are uniformly chosen) interactive protocols between a prover and verifier; when deriving results for non-interactive protocols, we implicitly assume we can get a proof length equal to the total communication of the prover, using the Fiat-Shamir transform/a random oracle. Using this reduction between interactive and non-interactive protocols, we can refer to the ``proof length'' of an interactive protocol. 

We allow our protocols to have access to a structured reference string (SRS) that can be derived in deterministic \poly-time from an ``SRS of monomials'' of the form
\sett{\enc1{x^i}}{a\leq i \leq b}, \sett{\enc2{x^i}}{c\leq i \leq d}, for uniform $x\in \F$,
and some integers $a,b,c,d$ with absolute value bounded by \poly.
It then follows from Bowe et al. \cite{SecondMPC} that the required SRS can be derived in a universal and updatable setup requiring only one honest participant; in the sense that an adversary controlling all but one of the participants in the setup does not gain more than a \negl advantage in its probability of producing a proof of any statement.

For notational simplicity, we sometimes use the SRS \srs as an implicit parameter in protocols, and do not explicitly write it.


\paragraph{Aurora lemma}
\begin{lemma}\label{lem:aurora}
 Let $H\subset \F$ be a multiplicative subgroup of size $t$.
 For $f\in\polysofdeg{t}$, we have 
\[\sum_{a\in H}f(a) = n\cdot a(0)\]
\end{lemma}



\subsection{Idealized verifier checks for algebraic adversaries}\label{subsec:agm}
We introduce some terminology from \cite{plonk} to capture analysis in the Algebraic Group Model of Fuchsbauer, Kiltz and Loss\cite{AGM}.

First we say our \srs \emph{has degree $Q$} if all elements of \srsi are of the form  \enci{f(x)} for $f\in \polysofdeg{Q}$ and uniform $x\in \F$. In the following discussion let us assume we are executing a protocol with a degree $Q$ SRS, and denote by $f_{i,j}$ the corresponding polynomial for the $j$'th element of \srsi.

Denote by $a,b$ the vectors of $\F$-elements whose encodings in $\G1,\G2$ an algebraic adversary \adv outputs during a protocol execution; e.g., the $j$'th $\G1$ element output by \adv is \enc1{a_j}.

By a ``real pairing check'' we mean a check of the form
\[(a\cdot T_1) \cdot (T_2\cdot b)=0\]
for some matrices $T_1,T_2$ over $\F$.
Note that such a check can indeed be done efficiently given the encoded elements and the pairing function $e:\G1\times \G2\to \Gt$.



Given such a ``real pairing check'', and the adversary \adv and protocol execution during which the elements were output, define the corresponding ``ideal check'' as follows.
Since \adv is algebraic when he outputs \enci{a_j} he also outputs a vector $v$ such that, from linearity, $a_j = \sum v_\ell f_{i,\ell}(x)=R_{i,j}(x)$ for $R_{i,j}(X) \defeq \sum v_\ell f_{i,\ell}(X)$.
Denote, for $i\in \set{1,2}$ the vector of polynomials $R_i=(R_{i,j})_j$.
The corresponding ideal check, checks as a polynomial identity whether
\[(R_1 \cdot T_1)\cdot (T_2\cdot R_2) \equiv 0\]


The following lemma is inspired by \cite{AGM}'s analysis of \cite{Groth16},
and tells us that for soundness analysis against algebraic adversaries it suffices to look at ideal checks.
Before stating the lemma we define the $Q$-DLOG assumption similarly to \cite{AGM}.
\begin{dfn}\label{ref:qdlog}
 Fix integer $Q$. The \emph{$Q$-DLOG assumption for $(\G1,\G2)$} states that given 
 \[\enc1{1},\enc1{x},\ldots,\enc1{x^Q},\enc2{1},\enc2{x},\ldots,\enc2{x^Q}\]
 for uniformly chosen $x\in \F$, the probability of an efficient \adv outputting $x$
 is \negl.
\end{dfn}



\begin{lemma}\label{lem:AGManalysis}
Assume the $Q$-DLOG for $(\G1,\G2)$.
 Given an algebraic adversary \adv participating in a protocol with a degree $Q$ SRS,
 the probability of any real pairing check passing is larger by at most an additive \negl factor than the probability the corresponding ideal check holds.
\end{lemma}


AGM - real and ideal pairing checks,
agm - real and ideal pairing 
KZG

\subsection{log derivative method}
Lemma from mvlookup
\begin{lemma}\label{lem:mvlookup}
 Given $f\in \F^\witsize$, and $t\in \F^\tabsize$,
 we have $f\subset t$ as sets if and only if for some $m\in \F^\tabsize$ the following identity of rational functions holds
 \[\sumi{\witsize}\frac{1}{X+f_i}=\sumi{\tabsize}\frac{m_i}{X+t_i}.\]
\end{lemma}

\section{Cached quotients}
\paragraph{Notation:}
In this section and the next we use the following conventions.
$\bigspace\subset \F$ denotes a mutliplicative subgroup of order $N$ which is a power of two.
We denote by \vgen a generator of \bigspace. Hence, $\bigspace=\set{\vgen,\vgen^2,\ldots,\vgen^\tabsize =1}$.
Given $P\in \F[X]$ and integer $i\in [\tabsize]$, we denote $P_i\defeq P(\vgen^i)$.
For $i\in [\tabsize]$, we denote by $L_i\in\polysofdeg{\tabsize}$ the $i$'th Lagrange polynomial of \bigspace. Thus, $(L_i)_i=1$ and $(L_i)_j=0$ for $i\neq j\in [\tabsize]$. 

For a polynomial $A(X)\in \polysofdeg{\tabsize}$, we say it is \emph{\witsize-sparse} if $A_i\neq 0$ for at most \witsize values $i\in[\tabsize]$.
The \emph{sparse representation} of such $A$ consists of the (at most) \witsize pairs $(i,A_i)$ such that $A_i\neq 0$.
We denote $\supp{A}\defeq\set{i\in [\tabsize]| A_i\neq 0}$.\\


The main result of this section is a method to compute a commitment to a quotient polynomial - derived from a product with a preprocessed polynomial; in a number of operations depending only on the sparsity of the other polynomial in the product. 

The result crucially relies on the following lemma derived from a result of Feist and Khovratovich\cite{fastkzgproofsorig}.

\begin{lemma}
\label{lem:cq-compute}
Fix $T\in \polysofdeg{\tabsize}$, and a subgroup $\bigspace\subset \F$ of size \tabsize. 
There is an algorithm that given the \G1 elements $\sett{\enc1{x^i}}{i\in \set{0,\ldots,\tabsize}}$ computes for $i\in [\tabsize]$, the elements 
$q_i\defeq \enc1{Q_i(x)}$
where $Q_i(X)\in \F[X]$ is such that
\[L_i(X)\cdot T(X)=T_i\cdot L_i(X) + Z_\bigspace(X)\cdot Q_i(X)\]
in $O(\tabsize\cdot \log \tabsize)$ \G1 operations.
 
\end{lemma}

\begin{proof} 
    Recall the definition of the Lagrange polynomial
    \[L_i(X) = \frac{Z_\bigspace(X)}{Z_\bigspace'(\vgen^i) (X - \vgen^i)}.\]
    Substituting this definition, we can write the quotient $Q_i(X)$ as 
    \[Q_i(X) = \frac{T(X) - T_i}{Z_\bigspace'(\vgen^i) (X - \vgen^i)} =
    Z_\bigspace'(\omega^i)^{-1} K_i(X), \]
for $K_i(X)\defeq \frac{T(X)-T_i}{X-\vgen^i}$.
Note that the values \sett{\enc1{K_i(X)}}{i\in [\tabsize]} are exactly the KZG opening proofs of $T(X)$ at the
elements of \bigspace.
    Thus, the algorithm of Feist and Khovratovich \cite{fastkzgproofsorig, fastkzgproofs} 
    can be used to compute commitments to all the proofs $\enc1{K_i(X)}$ 
    in $O(\tabruntime)$ \G1-operations. This works by writing the vector of
    $\enc1{K_i(X)}$ as a the product of a matrix with the vector of
    $\enc1{X^i}$. This matrix is a DFT matrix times a Toeplitz matrix, both of
    which have algorithms for evaluating matrix vector products in
    $O(\tabruntime)$ operations. Thus, all the KZG proofs can be computed in
    $O(\tabruntime)$ field operations and operations in \G1.
    
    Finally, the algorithm just needs to scale each $\enc1{K_i(X)}$ by
    $Z_{\bigspace}'(\omega^i)$ to compute $\enc1{Q_i(X)}$. Conveniently, these
    values admit a very simple description when $Z_\bigspace(X) = X^\tabsize -
    1$ is a group of roots of unity.
    \[Z_\bigspace'(X)^{-1} = (\tabsize X^{\tabsize-1})^{-1} \equiv X / \tabsize \mod Z_\bigspace(X)\] 

    In total, the prover computes the coefficients of $T(X)$ in $O(\tabruntime)$
    field operations, computes the KZG proofs for $T(\omega^i) = t_i$ in
    $O(\tabruntime)$ group operations, and then scales these proofs by $\omega^i
    / n$ in $O(\tabsize)$ group operations. In total, this takes
    $O(\tabruntime)$ field and group operations in \G1.
\end{proof}

We're now ready to state the main theorem of this section.

\begin{thm}
Fix integer parameters $0\leq n\leq N$ such that $n,N$ are powers of two. Fix $T\in \polysofdeg{\tabsize}$, and a subgroup $\bigspace\subset \F$ of size \tabsize. Let $\srs=\sett{\enc1{x^i}}{i\in[0,\ldots,\tabsize]}$ for some $x\in \F$. 
There is an algorithm \alg that after a preprocessing step of $O(\tabruntime)$ \F- and \G1-operations starting with \srs does the following.


Given input $A(X)\in \polysofdeg{\tabsize}$ that is \witsize-sparse and given in sparse representation, \alg computes in 
$O(\witsize)$ \F-operations and \witsize \G1-operations the element
$\cm=\enc1{Q(x)}$ where $Q\in \polysofdeg{\tabsize}$ is such that
\[A(X)\cdot T(X) = Q(X)\cdot Z_{\bigspace}(X) + R(X),\]
for $R(X)\in \polysofdeg{\tabsize}$.
\end{thm}
\begin{proof}
    The preprocessing step consists of computing the quotient commitments $\enc1{Q_i(X)}$ in $O(\tabruntime)$ operations, as described in Lemma \ref{lem:cq-compute}. As stated in the lemma,
    for each $i\in[\tabsize]$ we have
    \[L_i(X)\cdot T(X)=T_i\cdot L_i(X) + Z_\bigspace(X)\cdot Q_i(X).\]
    By assumption, the polynomial $A(X)$ can be written as a linear combination of
    at most $\witsize$ summands in the Lagrange basis of $\bigspace$.
    \[ A(X) = \sum_{i \in \supp{A}} A_i\cdot L_i(X) \]
    Substituting this into the product with $T(X)$, and substituting each of the products
    $L_i(X) T(X)$ with the appropriate cached quotient $Q_i(X)$ we find
    \[ A(X) T(X) = \sum_{i\in \supp{A}} A_i\cdot  L_i(X) T(X) =\sum_{i \in
    \supp{A}} A_i \cdot T_i L_i(X) + A_i\cdot Z_\bigspace(X) Q_i(X) \] 
   \[=\sum_{i \in  \supp{A}} A_i \cdot T_i L_i(X) +Z_\bigspace(X)\cdot \sum_{i \in
    \supp{A}} A_i \cdot Q_i(X).\] 
Observing that the terms of the first sum are all of degree smaller than \tabsize, we get that

    \begin{gather*}
Q(X)=\sum_{i \in  \supp{A}} A_i \cdot Q_i(X) \\
        R(X) = \sum_{i \in \supp{A}} A_i T_i \cdot L_i(X)
    \end{gather*}
    Hence, commitments to both the quotient $Q(X)$ and remainder $R(X)$ can be computed in
   at most \witsize group operations as 
    \begin{gather*}
        \enc1{Q(X)} = \sum_{i \in \supp{A}} A_i \cdot \enc1{Q_i(X)} \\
        \enc1{R(X)} = \sum_{i \in \supp{A}} A_i T_i \cdot \enc1{L_i(X)}
    \end{gather*}
\end{proof}


\section{$\cq\;$ - our main protocol}
\begin{dfn}\label{dfn:lookupprot}


$\gen(\tab,\tabsize,\srsbase=(\enc1{x^i},\enc2{x^i})_{i\in [0,\ldots,d})$:
\begin{enumerate}
 \item Compute for $i\in [\tabsize]$:
 \begin{enumerate}
  \item $q_i=\enc1{Q_i(x)}$ such that
  \[L_i(X)\cdot T(X)=T_i\cdot L_i(X) + Z_\bigspace(X)\cdot Q_i(X).\]
  \item $\enc1{L_i(x)},\enc1{x^{d-\tabsize}L_i(x)},\enc1{x^{d-\witsize}}$
  \item $\enc1{\frac{L_i(x)-L_i(0)}{x}}$.
 \end{enumerate}

\end{enumerate}


Tuple \gen,\isintable
\begin{itemize}
 \item $\gen(\tab,\tabsize,\srsbase)\to \srs$
 \item $\isintable$ an interactive public coin protocol between \prv and \ver where \prv has input $f\in \polysofdeg{\witsize}$, \ver has \enc1{f(x)}.
 Both have \tab and \srs.
 such that
 \begin{itemize}
  \item Completeness:If $\restricttoset{f}{\subspace}\subset \tab$ then \ver outputs \acc with probability one.
  \item Knowledge soundness in the algebraic group model:
   For any $\tab\in\F^\witsize$, the probability of any algebraic \adv to win the following game is \negl

\begin{enumerate}
\item We generate for uniform $x\in \F$, $\srs0=(\enc1{x^i},\enc2{x^i})_{i\in [0,\ldots,d}$.
\item \adv chooses  $\tab\in \F^\tabsize$.
 \item We compute $\srs=\gen(\tab,\tabsize,\srs0)$.
 \item \adv sends a message \cm and values $f_1,\ldots, f_\witsize$ such that $\cm=\sumi{\witsize}f_i\cdot \enc1{L_i(x)}$.
 \item \adv and \ver engage in the protocol $\isintable(\tab,\cm)$ with \adv taking the role of \prv.
 \item \adv wins if 
 \begin{itemize}
  \item \ver outputs \acc, and
  \item $\restricttoset{f}{\subspace}\not\subset \tab$.
 \end{itemize}

\end{enumerate}
\end{itemize}
\end{itemize}
\end{dfn}
Main protocol:
Preprocessed inputs:
\enc2{Z_\bigspace(x)}, \enc2{T(x)}
Input $(\cm,f)$.
	\paragraph{\textbf{Round 1:} Committing to the multiplicites vector} \ \\
\begin{enumerate}
 \item \prv computes poly $m\in \polysofdeg{\tabsize}$ such that $m_i=$ number of times $\tab_i$ appears in \restricttoset{f}{\subspace}
 \item \prv sends $\m\defeq \enc1{m(x)}$.
 \end{enumerate}
	\paragraph{\textbf{Round 2:} Interpolating the rational identity at a random $\beta$; checking correctness of  $A$'s values + degree checks for $A,B$ using pairings} \ \\
 
\begin{enumerate}
 \item \ver chooses and sends random $\alpha,\beta \in \F$.
\item \prv computes $A\in \polysofdeg{\tabsize}$ such that for $i\in [\tabsize]$, $A_i = m_i/(\tab_i+\beta)$.
\item \prv sends $\a\defeq \enc1{A(x)}$.
\item\label{step:computeQA} \prv computes $\qa \defeq \enc2{Q_A(x)}$ where $Q_A\in \polysofdeg{\tabsize}$ is such that 
\[A(X)(T(X)+\beta)-m(X)= Q_A(X)\cdot Z_\bigspace(X)\]
\item \prv computes $B\in \polysofdeg{\witsize}$ such that for $i\in [\witsize]$, $B_i=1/(f_i+\beta)$.
\item \prv sends $\qb\defeq \enc1{B(x)}$.
\item \prv computes $Q_B(X)$ such that 
\[B(X)(f(x)+\beta)-1 = Q_B(X)\cdot Z_\subspace(X)\]
\item \prv computes and sends the value $a_0\defeq A(0)$.
\item \ver  sets $b_0\defeq (\tabsize\cdot a_0)/\witsize$.
\item \prv computes and sends $\p=\enc1{P(x)}$ where
\[P(X)\defeq A(X)\cdot X^{d-\tabsize}+\alpha\cdot B(X)\cdot X^{d-\witsize}. \]
\item\label{step:checkqa} \ver checks that $A$ encodes the correct values:
\[e(\a,\enc2{T(x)}+\enc2{\beta} )=e(\qa,\enc2{Z_\bigspace(x)})\cdot e(\m,\enc2{1})\]
\item\label{step:checkadeg} \ver checks that $A,B$ have the appropriate degrees:
\[e\left(\a,\enc2{x^{d-\tabsize}}\right)\cdot e\left(\alpha\cdot \b,\enc2{x^{d-\witsize}}\right)=e(\p,\enc2{1}).\]
 \end{enumerate}
	\paragraph{\textbf{Round 3:} Checking correctness of  $B$ at random $\gamma \in \F$}
 \begin{enumerate}
\item \ver sends random $\gamma,\eta,\zeta \in \F$.
\item \prv sends $\bgam \defeq B(\gamma),\fgam \defeq f(\gamma)$.
\item\label{step:setQB} As part of checking the correctness of $B$, \ver computes $ Z_\subspace(\gamma) = \gamma^\witsize -1$ and
\[\qbgam\defeq \frac{\bgam\cdot (\fgam + \beta)-1}{Z_\subspace(\gamma)}.\]
\item To perform a batched KZG check for the correctness of the values  $\agam,\bgam,\fgam$
  \begin{enumerate}
   \item \ver sends random $\eta\in \F$. \prv and \ver separately compute
   \[v\defeq \bgam +\eta\cdot\fgam + \eta^2\cdot \qbgam.\]
   \item \prv computes $\gamproof\defeq \enc1{h(x)}$ for 
   \[h(X)\defeq \frac{ B(X)+ \eta\cdot f(X) + \eta^2\cdot Q_B(X) -v}{X-\gamma}\]
   \item\label{step:checkKZG1} \ver computes 
   \[\c\defeq \b+\eta\cdot \f +\eta^2\cdot \qb\]
   and  checks that 
   \[e(\c-\enc1{v}+\gamma\cdot \gamproof,\enc2{1})=e(\gamproof,\enc2{x})\]
  \end{enumerate}
\item To perform a batched KZG check for the correctness of the values  $a_0,b_0$
  \begin{enumerate}
   \item  \prv and \ver separately compute
   \[u\defeq a_0+\zeta \cdot b_0.\] 
   \item \prv computes and sends $\zerproof\defeq \enc1{h_0(x)}$ for 
   \[h_0(X)\defeq \frac{A(X)+\zeta\cdot B(X)}{X}\]
   \item\label{step:checkKZG2} \ver computes 
   \[\c_0 \defeq \a +\zeta \b\]
   and  checks that 
   \[e(\c_0-\enc1{u},\enc2{1})=e(\zerproof,\enc2{x})\]
  \end{enumerate}

\end{enumerate}

\paragraph{Stats:}

verifier pairings:5 - pair \a with random combination of $T$ and \enc2{x^{d-\tabsize}}, pair \qa with $Z_\bigspace$.
pair \b with \enc2{d-\witsize} for degree check.
Proof size - 8 \G1 - \a,\b,\p,\m,\qa,\qb\gamproof,\zerproof    
                     4 \F- \bgam,\qbgam,\fgam,$a_0$
                     
                     
                     
    Note that we can split \p to two proofs and that reduces a verifier pairing

\begin{lemma}\label{lem:computeQA}
The element $q_A$ in Step \ref{step:computeQA} can be computed in  \witruntime \G2-operations and $O(\witruntime)$ \F-operations
\end{lemma}
\begin{lemma}\label{lem:computeKZGproofs}
The elements $\zerproof,\gamproof$ can be computed in  $2\cdot\witruntime$ \G1-operations and $O(\witruntime)$ \F-operations
\end{lemma}

\paragraph{Knowledge soundness proof:}
Let \adv be an efficient algebraic adversary participating in the Knowledge Soundness game from
Definition \ref{dfn:lookupprot}.
We show its probability of winning the game is \negl.
Let $f\in \polysofdeg{d}$ be the polynomial sent by \adv in the first step of the game
such that $\cm=\enc1{f(x)}$.
As \adv is algebraic, when sending the commitments \m,\a,\b,\p,\qa,\qb,\gamproof,\zerproof during protocol execution it also sends polynomials $m(X),A(X),B(X),P(X),Q_A(X),Q_B(X),h(X),h_0(X)\in \polysofdeg{d}$ such that the former are their corresponding commitments.
Let $E$ be the event \ver outputs \acc.
Note that the event that \adv wins the game is contained in $E$. 
$E$ implies all pairing checks passed.
Let $A\subset E$ be the event that one of the corresponding ideal pairing checks didn't pass.
According to Lemma \ref{lem:AGManalysis}, $\prob(A=\negl)$.
% We'll show that the event that \adv wins is contained in $E`$.
% Let $E_1=E\setminus E`$.
Given $A$ didn't occur, we have
\begin{itemize}
 \item From step \ref{step:checkqa} \[A(X)(T(X)+\beta)-M(X) = Q_A(X)\cdot Z_\bigspace(X)\]
Which means that for all $i\in [\tabsize]$,
\[A_i=\frac{M_i}{T_i+\beta)}\]

\item From step  \ref{step:checkadeg}
\[X^{d-\tabsize}A(X)+\alpha\cdot X^{d-\witsize}B(X)=P(X),\]
which implies e.w.p. $1/|\F|$ over $\alpha\in \F$, that $\deg(A)<\tabsize$ and $\deg(B)<\witsize$.

\item From the checks of steps \ref{step:checkKZG1} and \ref{step:checkKZG2},  e.w.p. $\witsize/|\F|$ over $\eta,\zeta\in\F$ (see e.g. Section 3 of \cite{plonk} for an expalantion of the correctness of batched KZG \cite{kate}). 
$\bgam = B(\gamma),\qbgam =Q_B(\gamma),\fgam =f(\gamma),a_0=A(0),b_0=B(0)$.

\item Which implies by how \qbgam is set in step \ref{step:setQB}  that e.w.p. $(2\witsize)/|\F|$ over $\gamma$ 
\[B(X)\cdot (f(X)+\beta)=1+ Q_B(X)Z_\subspace(X),\]
which implies for all $i\in [\witsize]$ that
$B(\hgen^i)=\frac{1}{f(\hgen^i)+\beta}$.
\item We know have using Lemma \ref{lem:aurora} that
\[\tabsize\cdot a_0 = \sum_{i\in [\tabsize]} A_i = \sum_{i\in [\tabsize]}\frac{m_i}{T_i+\beta)}\]
\[\witsize\cdot b_0 = \sum_{i\in [\witsize]} B(\hgen^i) = \sum_{i\in [\witsize]}\frac{1}{f(\hgen^i)+\beta}\]
Thus e.w.p. $(\witsize\cdot \tabsize)/|\F|$ over $\beta\in \F$, we have that
\[\sum_{i\in [\tabsize]}\frac{m_i}{T_i+X)}=\sum_{i\in [\witsize]}\frac{1}{f(\hgen^i)+X},\]
which implies $\restricttoset{f}{\subspace}\in \tab$.
\end{itemize}
In summary, we have shown the event that \ver outputs \acc while $\restricttoset{f}{\subspace}\not\subset \tab$
is contained in a constant number of events with probability \negl; and so \cq satisfies the knowledge soundness property.

\section{\cqstar}
The only point where \prv does $O(\witruntime)$ operations in \cq is using FFT's to compute $Q_B(X)$. Similarly to what we did with $Q_A(X)$ we could 
try to only compute the commitment \enc1{Q_B(x)}
$\gen(\tab,\srs)$

Main protocol:
Preprocessed inputs:
\enc2{Z_\bigspace(x)}, \enc2{T(x)}
Input $(\cm,f)$.
	\paragraph{\textbf{Round 1:} Committing to the multiplicites vector, and $f$ in \G2} \ \\
\begin{enumerate}
 \item \prv computes poly $m\in \polysofdeg{\tabsize}$ such that $m_i=$ number of times $\tab_i$ appears in \restricttoset{f}{\subspace}
 \item \prv sends $\m\defeq \enc1{m(x)}$.
 \item \prv sends $\ftwo \defeq \enc2{f(x)}$
 \item \ver checks correctness of \ftwo via
 \[e(\f,\enc2{1})=e(\enc1{1},\ftwo).\]
 \end{enumerate}
	\paragraph{\textbf{Round 2:} Interpolating the rational identity at a random $\beta$; checking correctness of degrees and values of  $A,B$ using pairings} \ \\
 
\begin{enumerate}
 \item \ver chooses and sends random $\alpha,\beta \in \F$.
\item \prv computes $A\in \polysofdeg{\tabsize}$ such that for $i\in [\tabsize]$, $A_i = m_i/(\tab_i+\beta)$.
\item \prv sends $\a\defeq \enc1{A(x)}$.
\item\label{qstr-step:computeQA} \prv computes $\qa \defeq \enc2{Q_A(x)}$ where $Q_A\in \polysofdeg{\tabsize}$ is such that 
\[A(X)(T(X)+\beta)-m(X)= Q_A(X)\cdot Z_\bigspace(X)\]
\item \prv computes $B\in \polysofdeg{\witsize}$ such that for $i\in [\witsize]$, $B_i=1/(f_i+\beta)$.
\item \prv sends $\qb\defeq \enc1{B(x)}$.
\item \prv computes $\qb\defeq \enc1{Q_B(X)}$ such that 
\[B(X)(f(x)+\beta)-1 = Q_B(X)\cdot Z_\subspace(X)\]
\item \prv computes and sends the value $a_0\defeq A(0)$.
\item \ver  sets $b_0\defeq (\tabsize\cdot a_0)/\witsize$.
\item \prv computes and sends $\p=\enc1{P(x)}$ where
\[P(X)\defeq A(X)\cdot X^{d-\tabsize}+\alpha\cdot B(X)\cdot X^{d-\witsize}. \]
\item\label{qstr-step:checkqa} \ver checks that $A$ encodes the correct values:
\[e(\a,\enc2{T(x)}+\enc2{\beta} )=e(\qa,\enc2{Z_\bigspace(x)})\cdot e(\m,\enc2{1})\]
\item\label{qstr-step:checkqb} \ver checks that $B$ encodes the correct values:
\[e(\b,\enc2{\f}+\enc2{\beta} )=e(\qb,\enc2{Z_\subspace(x)})\cdot e(\enc1{1},\enc2{1})\]
\item\label{qstr-step:checkadeg} \ver checks that $A,B$ have the appropriate degrees:
\[e\left(\a,\enc2{x^{d-\tabsize}}\right)\cdot e\left(\alpha\cdot \b,\enc2{x^{d-\witsize}}\right)=e(\p,\enc2{1}).\]
 \end{enumerate}
	\paragraph{\textbf{Round 3: Checking correctness of $A(0),B(0)$}}
 \begin{enumerate}
\item \ver sends random $\zeta \in \F$.
\item To perform a batched KZG check for the correctness of the values  $a_0,b_0$
  \begin{enumerate}
   \item  \prv and \ver separately compute
   \[u\defeq a_0+\zeta \cdot b_0.\] 
   \item \prv computes and sends $\zerproof\defeq \enc1{h_0(x)}$ for 
   \[h_0(X)\defeq \frac{A(X)+\zeta\cdot B(X)}{X}\]
   \item\label{step:checkKZG2} \ver computes 
   \[\c_0 \defeq \a +\zeta \b\]
   and  checks that 
   \[e(\c_0-\enc1{u},\enc2{1})=e(\zerproof,\enc2{x})\]
  \end{enumerate}
\end{enumerate}

\paragraph{Stats:}

verifier pairings:5 - pair \a with random combination of $T$ and \enc2{x^{d-\tabsize}}, pair \qa with $Z_\bigspace$.
pair \b with \enc2{d-\witsize} for degree check.
Proof size - 6 \G1 - \a,\b,\p,\m,\qa,\qb,\zerproof    
                      1 \G2 - \ftwo
                      1 \F- $a_0$
                     

\bibliographystyle{alpha}
\bibliography{references}
\end{document}


